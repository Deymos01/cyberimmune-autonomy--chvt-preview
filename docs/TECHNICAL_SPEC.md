# Техническое задание


## Введение

В современных системах управления автономными наземными транспортными средствами (АНТС) особое значение приобретают безопасность, управляемость и масштабируемость архитектуры. Для повышения уровня контроля над выполнением заданий и гибкости в управлении маршрутами необходимо внедрение дополнительных компонентов, обеспечивающих аутентификацию отправителей и централизованное управление маршрутной информацией.

Настоящее техническое задание описывает расширение существующей архитектуры ANTS-системы за счёт добавления двух ключевых модулей:

- **Блока контроля доступа (Access Control Block)** — для обеспечения авторизации отправителей заданий;
- **Менеджера ресурсов (Resource Manager)** — для хранения, обработки и предоставления данных маршрутов по запросу.

Данное расширение направлено на реализацию более строгой модели безопасности, в которой исполнение маршрутов возможно только после успешной проверки прав доступа, а маршруты идентифицируются и извлекаются по уникальным идентификаторам. Это позволяет упростить структуру входящих заданий, повысить надёжность системы и обеспечить её соответствие требованиям к промышленным и транспортным решениям.

В документе подробно изложены цели проекта, архитектурные изменения, формат взаимодействия компонентов, требования к реализации и тестированию, а также логика интеграции с уже существующими модулями системы.


## Описание шаблона из стандарта

Шаблон «Раздельное принятие и применение решений о безопасности» предназначен для реализации активного механизма контроля доступа и фильтрации потоков данных/потоков управления на основе заданных правил и политик безопасности. Шаблон предполагает разделение механизмов принятия решения о возможности доступа или разрешении потока и применения этого решения к потокам данных, потокам управления и выполняемым в системе операциям. Это в конечном счете позволяет улучшить гибкость работы механизма контроля доступа и/или фильтрации потоков данных/потоков управления в системе и оптимизировать доказательство корректности его работы.


## 1. Цель проекта

Расширить существующую архитектуру системы управления автономным наземным транспортным средством (АНТС) путем внедрения двух новых компонентов:

- **Блок контроля доступа (Access Control Block)** – отвечает за проверку подлинности запросов, исходящих от отправителей заданий.
- **Менеджер ресурсов (Resource Manager)** – обеспечивает хранение и управление регулярными маршрутами, реализуя файловую систему маршрутов.

Новое решение должно гарантировать, что только уполномоченные отправители смогут активировать выполнение маршрутов, хранящихся в файловой системе, при этом в задание передаются лишь идентификаторы отправителя и маршрута.

## 2. Структура передачи заданий (миссий)

**Новый формат задания:**  
Вместо передачи полного объекта маршрута миссия должна содержать только идентификатор отправителя (`sender_id`) и идентификатор маршрута (`route_id`).

**Пример:**

```json
{
    "sender_id": "sender_01",
    "route_id": "route_001"
}
```

## Цепочка обработки

1. Входящий запрос (миссия) поступает в **CommunicationGateway**.
2. Сначала осуществляется **проверка через блок контроля доступа**.
3. При положительном результате запрос передаётся в **Менеджер Ресурсов** для извлечения полного маршрута.
4. После получения полного маршрута данные комбинируются с информацией об отправителе и передаются в соответствующие очереди для дальнейшей обработки (например, в `ControlSystem` и `SafetyBlock`).

---

## 3. Блок контроля доступа (Access Control Block)

#### Приём запроса

Модуль должен принимать запросы, содержащие:

- `sender_id` – идентификатор отправителя
- `route_id` – идентификатор маршрута

#### Проверка прав доступа

Система должна содержать внутреннее хранилище или конфигурацию, в которой для каждого отправителя указаны разрешённые маршруты.

**Пример структуры данных:**

```python
allowed_mapping = {
    "sender_01": ["route_001", "route_005"],
    "sender_02": ["route_002", "route_003"],
    # ...
}
```

### Логика проверки

Метод `_process_access_request(sender_id, route_id)` должен:

- Получать список разрешённых маршрутов для данного отправителя.
- Вызывать метод `_forward_to_resource_manager(sender_it, route_id)`, если `route_id` присутствует в списке.
- Вызывать метод `_send_rejection(sender_it, route_id)`, если запрос не авторизован.

#### Логирование

При неудачной проверке система должна зафиксировать событие (логирование ошибки), указывая, что доступ для данного отправителя и маршрута запрещён.

---

## 4. Менеджер ресурсов (Resource Manager)

#### Хранение маршрутов

Маршруты должны храниться:

- В виде отдельных файлов (например, `.json`).
- В демонстрационном варианте допустимо использование встроенного словаря.
- Для реального внедрения предпочтительно использовать файловую систему.

**Пример файла маршрута (JSON):**

```json
{
  "points": [
    {"lat": 55.7558, "lon": 37.6176},
    {"lat": 55.7522, "lon": 37.6156}
  ],
  "speed_limit": 60
}
```

### Получение маршрута

На основании входящего `route_id` модуль должен:

- Искать соответствующий файл или запись в хранилище.
- Извлекать данные.
- Возвращать их в виде объекта (например, словаря Python).

### Обработка ошибок

Если маршрут не найден, модуль должен:

- Сгенерировать исключение или уведомить вызывающий код об отсутствии данных.
- Записать информацию в лог об ошибке (например, `"Маршрут с id route_001 не найден"`).

---

## 5. Изменение формата задания (миссии)

### 5.1. Функциональные требования

#### Формат входного запроса

Новая миссия должна содержать только два поля:

- `sender_id`
- `route_id`

#### Валидация запроса

На этапе формирования запроса необходимо предварительно проверить, что:

- Оба идентификатора переданы.
- Оба идентификатора не пустые.

#### Комбинирование данных

После успешной проверки доступа (см. раздел 3):

- Менеджер Ресурсов получает данные маршрута.
- Вся информация формируется в единый объект, который передаётся дальше в систему.

---

### 5.2. Требования к реализации

Изменить код в `CommunicationGateway` (или аналогичном модуле), чтобы он:

1. Извлекал `sender_id` и `route_id` из входящих параметров.
2. Вызывал блок контроля доступа для проверки прав.
3. При положительном результате вызывал Менеджер Ресурсов для загрузки маршрута.
4. Объединял данные для формирования окончательного объекта миссии.

**Формат конечного объекта миссии:**

```python
mission_data = {
    "sender_id": "sender_01",
    "route": { ... данные маршрута ... }
}
```

## 6. Интеграция нового функционала

### 6.1. Последовательность обработки запроса

#### Проверка доступа

- Идентификаторы передаются в блок контроля доступа.
- Если проверка возвращает `False`:
  - Запрос отклоняется.
  - Происходит логирование ошибки.
- Если проверка возвращает `True`, запрос передается на следующий этап.

#### Загрузка маршрута

- Менеджер ресурсов получает `route_id`.
- Если маршрут найден:
  - Извлекается и возвращается.
- Если маршрут не найден:
  - Генерируется уведомление об ошибке.
  - Запрос отклоняется.

#### Формирование и отправка миссии

- На основе данных проверки и маршрута формируется итоговый объект миссии.
- Объект передаётся в соответствующие очереди.
- Очереди назначения определяются конфигурацией:
  - `CONTROL_SYSTEM_QUEUE_NAME`
  - `SAFETY_BLOCK_QUEUE_NAME`
- Сообщения отправляются как экземпляры класса `Event`.

---

### 6.2. Техническое взаимодействие с другими компонентами

#### CommunicationGateway

- Необходимо модернизировать метод `_send_mission_to_consumers`, чтобы он выполнял следующие действия:
  - Извлечение идентификаторов.
  - Проверка доступа.
  - Загрузка маршрута.
  - Формирование и отправка объекта миссии.

#### ControlSystem и SafetyBlock

- Принимают событие с объектом миссии.
- Ожидаемые поля:
  - `route` — полный маршрут.
  - `sender_id` — идентификатор отправителя.
- Обработка выполняется стандартными алгоритмами.

---

## 7. Требования к тестированию

- Проверка полной цепочки обработки запроса:
  1. Получение `sender_id` и `route_id`.
  2. Проверка доступа.
  3. Загрузка маршрута.
  4. Формирование и отправка объекта миссии в очереди.
- Моделирование отказов:
  - Отказ доступа.
  - Отсутствие маршрута.
- Убедиться, что система корректно обрабатывает исключительные ситуации.


## 8. Анализ решения

В данном разделе проводится сравнение описания шаблона «Раздельное принятие и применение решений о безопасности» и разработанной реализации, а также обосновывается соответствие реализации ключевым свойствам шаблона.

### 8.1. Разделение принятия решения и применения

- **Шаблон**: рекомендует выносить логику принятия решения о доступе (authorization decision) в один компонент, а применение этого решения к конкретным потокам данных или управляющим командам — в другой.  
- **Реализация**:  
  - **Access Control Block** отвечает только за проверку (`is_allowed(sender_id, route_id)`) и логирование результата.  
  - **Resource Manager** занимается извлечением (фильтрацией) и передачӗю полного маршрута только после положительного решения.  

Таким образом, решение о разрешении/запрете доступа и фактическая загрузка маршрута разделены по модулям, что соответствует требованиям шаблона.

### 8.2. Активный механизм контроля и фильтрация потоков

- **Шаблон**: описывает активный механизм фильтрации потоков данных/управления на основе заранее заданных политик.  
- **Реализация**:  
  - Сначала вызывается Access Control Block для проверки прав.  
  - Если проверка не пройдена, дальнейшая передача данных (полного объекта маршрута) блокируется, и события фиксируются в логе.  
  - Если проверка успешна, только тогда **Resource Manager** «пропускает» поток запроса к файловой системе маршрутов.

